---
interface Props {
  animation: AnimationName;
  animationMobile?: AnimationName;
  duration?: string;
  timingFunction?: string;
  delay?: string;
  fillMode?: string;
  className?: string;
  showOnScroll?: boolean;
}

export enum AnimationName {
  FADE_IN = 'fade-in',
  FADE_IN_UP = 'fade-in-up',
  FADE_IN_RIGHT = 'fade-in-right',
  FADE_IN_DOWN = 'fade-in-down',
  FADE_IN_LEFT = 'fade-in-left',
}

const {
  animation,
  animationMobile,
  duration,
  timingFunction,
  delay,
  fillMode,
  className,
  showOnScroll,
} = Astro.props;
---

<div
  class=`fade-in-element ${showOnScroll && 'fade-in-scroll'}`
  data-animation={animation}
  data-animation-mobile={animationMobile}
>
  <div class={`animation-target opacity-0 ${className || ''}`}>
    <slot />
  </div>
</div>

<style define:vars={{ duration, timingFunction, delay, fillMode }}>
  .opacity-0 {
    opacity: 0;
  }

  .fade-in-reverse {
    animation-direction: reverse;
  }

  .fade-in-effect {
    opacity: 0;
    animation-name: var(--animationName);
    animation-duration: var(--duration, 0.8s);
    animation-timing-function: var(--timingFunction, ease-in-out);
    animation-delay: var(--delay, 0s);
    animation-fill-mode: var(--fillMode, forwards);
  }

  .fade-out-effect {
    opacity: 1;
    animation-name: var(--reverseAnimation);
    animation-duration: var(--duration, 0.8s);
    animation-timing-function: var(--timingFunction, ease-in-out);
    animation-delay: var(--delay, 0s);
    animation-fill-mode: var(--fillMode, forwards);
  }

  @keyframes fade-in {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }

  @keyframes fade-in-up {
    0% {
      opacity: 0;
      transform: translateY(20px);
    }

    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes fade-in-right {
    0% {
      opacity: 0;
      transform: translateX(-20px);
    }
    100% {
      opacity: 1;
      transform: translateX(0);
    }
  }

  @keyframes fade-in-down {
    0% {
      opacity: 0;
      transform: translateY(-20px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes fade-in-left {
    0% {
      opacity: 0;
      transform: translateX(20px);
    }
    100% {
      opacity: 1;
      transform: translateX(0);
    }
  }

  @keyframes fade-out {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }

  @keyframes fade-out-up {
    0% {
      opacity: 1;
      transform: translateY(0);
    }
    100% {
      opacity: 0;
      transform: translateY(-20px);
    }
  }

  @keyframes fade-out-right {
    0% {
      opacity: 1;
      transform: translateX(0);
    }
    100% {
      opacity: 0;
      transform: translateX(20px);
    }
  }

  @keyframes fade-out-down {
    0% {
      opacity: 1;
      transform: translateY(0);
    }
    100% {
      opacity: 0;
      transform: translateY(20px);
    }
  }

  @keyframes fade-out-left {
    0% {
      opacity: 1;
      transform: translateX(0);
    }
    100% {
      opacity: 0;
      transform: translateX(-20px);
    }
  }
</style>

<script>
  const fadeElements = Array.from(document.querySelectorAll('.fade-in-element'));
  const fadeScrollElements = Array.from(fadeElements).filter(element =>
    element.classList.contains('fade-in-scroll'),
  );

  fadeElements.forEach(element => {
    if (element instanceof HTMLElement) {
      const animationMobile = element.dataset.animationMobile;
      let animation = element.dataset.animation;

      if (animationMobile) {
        if (window.innerWidth <= 768) {
          animation = animationMobile;
        }
      }

      if (animation) {
        const reverseAnimation = animation.replace('in', 'out');
        element.style.setProperty('--animationName', animation);
        element.style.setProperty('--reverseAnimation', reverseAnimation);

        if (!element.classList.contains('fade-in-scroll')) {
          const animationTarget = element.querySelector('.animation-target') as HTMLElement;
          animationTarget.classList.add('fade-in-effect');
        }
      }
    }
  });

  const intersectionCallback = (entries: IntersectionObserverEntry[]): void => {
    entries.forEach(entry => {
      const animationTarget = entry.target.querySelector('.animation-target') as HTMLElement;
      if (entry.isIntersecting) {
        animationTarget.classList.remove('fade-out-effect');
        animationTarget.classList.add('fade-in-effect');
      } else {
        animationTarget.classList.remove('fade-in-effect');
        animationTarget.classList.add('fade-out-effect');
      }
    });
  };

  const observer = new IntersectionObserver(intersectionCallback, {
    root: null,
    rootMargin: '0px 0px -8% 0px',
    threshold: 0.2,
  });

  fadeScrollElements.forEach(element => {
    observer.observe(element);
  });

  // Cleanup function
  document.onvisibilitychange = () => {
    if (document.visibilityState === 'hidden') {
      observer.disconnect();
      return;
    }

    fadeScrollElements.forEach(element => {
      observer.observe(element);
    });
  };
</script>
